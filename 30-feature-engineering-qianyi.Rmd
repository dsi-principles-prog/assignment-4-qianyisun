---
title: "30-feature-engineering"
output: html_notebook
---

# 4. Using best practices, write four functions which add engineered features to the dataset, including a description and rationale. Include a test to determine whether the features are working as intended.

## 4.1 Feature engineering: Size in MB
In order to further better observe the relationship between user ratings and  bytes size of the application, I add the new feature function called size_MB. The new feature function is transformed from the size_bytes column. We all know the 1MB=1024KB and 1KB = 1024 Byte. Thus 1M is equal to '1024*1024 bytes'. Now I create the function to realize the procedure.
```{r size_MB}
size_MB<-function(df){
  df %>% 
    mutate(size_MB=size_bytes/(1024*1024))

}

```

```{r test size_MB function}
df %>% 
  size_MB() %>% 
  assert(within_bounds(lower.bound = 0, upper.bound = Inf, allow.na = FALSE), size_MB)

```
I did the test above. By the test, we can find that the size_MB values still belong to rational range.That proves that the new feature function works as intended.

## 4.2 Feature engineering: evaluate the rank of Content Rating
To easily recognize the level of content rating, I decided to define three kinds of satisfaction degrees. I create a new feature function called cont_rating_degree to show what I want. When the content rating is the range between 0 and 6, then I define it as "low" level content rating. The value is higher than six but its value is smaller than or equal to 12, then I defined as "normal" level content rating. Finally, for the value that is higher than 12, I defined it as "high" level content rating.
```{r cont_rating_degree function}
cont_rating_degree<-function(df){
    df %>% 
    mutate(cont_rating_degree = case_when(
      cont_rating <= 6 ~ "Low",
      cont_rating <= 12 ~"Normal",
      TRUE ~ "High"
    ))
}
```

```{r test cont_rating_degree function }
df %>% 
  cont_rating_degree() %>% 
  assert(in_set(c("Low", "Normal", "High")), cont_rating_degree)
```
I did the test above. By the test, we can find that the cont_rating_degree values only have three possiblities including Low, Normal and High. Thus this proves that the new feature function works as intended.

## 4.3 Feature engineering: average User Rating counts of supporting devices
In order to explore the relationship between user ratings and average User Rating counts of supporting devices, now I create a feature function called avg_rating_count_ver.This new column of value is equel to the value that rating_count_ver divides sup_devices_num(Number of supporting devices).
```{r avg_rating_count_ver function}
avg_rating_count_ver<-function(df){

df %>% 
    mutate(avg_rating_count_ver = rating_count_ver/sup_devices_num)
}

```

```{r test avg_rating_count_ver function}
df %>% 
  avg_rating_count_ver() %>% 
  assert(within_bounds(lower.bound = 0, upper.bound = Inf, allow.na = FALSE),avg_rating_count_ver)

```
I did the test above. By the test, we can find that the avg_rating_count_ver values are in reasonable range. Therefore this proves that the new feature function works as intended.

## 4.4 Feature engineering: evaluate the rank of price
Because the value of price do not show the the level of price. Thus I do define three kinds of price degree to solve this problem and at the same time it also can be better to observe whether the relation exist between user rating and price. When the price is the range between 0 and 5, I define it as "low" level price. If the value of price is higher than 5 but its value is smaller than or equal to 10, then I defined it as "normal" level price. In the end, for the value of price that is higher 10, I defined it as "high" level price.

```{r price_degree function}
price_degree<-function(df){
    df %>% 
    mutate(price_degree = case_when(
      price <= 5 ~ "Low",
      price <= 10 ~"Normal",
      TRUE ~ "High"
    ))
}

```

```{r test price_degree function}
df %>% 
  price_degree() %>% 
  assert(in_set(c("Low", "Normal", "High")), price_degree)
```
I did the test above. By the test, we can find that price_degree values only have three possiblities including Low, Normal and High. Thus the result is what I wanted.

# 5. Prepare the data for modeling

## adding the new four feature into the dataset
In order to further model preparation, I added the four new feature into the data. I think the new features can have some relationship to help me evaluate the user ratings.
```{r prepare the data}
df <- df %>%    
  size_MB() %>% 
  cont_rating_degree() %>% 
  avg_rating_count_ver() %>%
  price_degree()

head(df)

```
Now we can do the further model exploration.



